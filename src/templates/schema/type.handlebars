{{~#*inline "complexFieldClass" ~}}
{{ multilineComment description }}
class {{ className }}Arguments extends Equatable {
  const {{ className }}Arguments({
    {{#each arguments}}{{#if name}}
      this.{{ dartName name }},
    {{/if}}{{/each}}
  });

  {{#each arguments}}{{#if type}}{{#if name}}
  {{#if description }}{{ multilineComment description }}
  {{/if}}
  {{ resolveType type
      "final"
      (takeFirst contextName ../contextName)
      (takeFirst contextModels ../contextModels)
      isArray
      raw
      ../name
  }} {{ dartName name }};
  {{~/if}}{{/if}}{{/each}}

  @override
  List<Object> get props => [
    {{~#each arguments}}{{#if name}}{{ dartName name }},
    {{/if}}{{/each~}}
  ];
}

@immutable
class {{ className }}Results extends FieldResults<{{ className }}Arguments, {{resultType}}> {

  const {{ className }}Results(Map<{{ className }}Arguments, {{resultType}}> results): super(results);

  {{resultType}} call({
    {{#each arguments}}{{#if name}}
      {{ resolveType type
          'inline'
          (takeFirst contextName ../contextName)
          (takeFirst contextModels ../contextModels)
          isArray
          raw
          ../name
      }} {{dartName name}},
    {{~/if}}{{/each}}
  }) => results[{{ className }}Arguments(
    {{#emptySafeEach arguments required='name' }}
      {{ dartName name }}: {{ dartName name }},
    {{/emptySafeEach}}
  )];
}
{{~/inline~}}

{{#unless (
  ignoreType
    name
      @root.config.replaceTypes
      typeName
      @root.config.irreducibleTypes
)}}

{{#each fields}}{{#if type}}{{#if name}}{{#if arguments}}

{{> complexFieldClass this
    resultType=(
      resolveType
        type
        'inline'
        (takeFirst contextName ../contextName)
        (takeFirst contextModels ../contextModels)
        isArray
        raw
        ../name
    )
    className=(concat ../name (toPascalCase name))
}}

{{~/if}}{{~/if}}{{/if}}{{/each}}

{{ multilineComment description }}
@immutable
class {{ name }} extends GraphQLObjectType<{{ name }}> {{
  classExtends
    interfaces=interfaces
    mixins=(arrayify 'EquatableMixin')
  }} {

  {{ name }}({
    {{#each fields}}{{#if name}}
      this.{{ dartName name }},
    {{/if}}{{/each}}
  });

  {{#each fields}}{{#if type}}{{#if name}}
  {{#if description }}{{ multilineComment description }}
  {{/if}}
  {{#if arguments}}
  final {{../name}}{{ toPascalCase name }}Results {{ dartName name }};
  {{else}}
  {{ resolveType type
      "final"
      (takeFirst contextName ../contextName)
      (takeFirst contextModels ../contextModels)
      isArray
      raw
      ../name
  }} {{ dartName name }};
  {{/if}}
  {{~/if}}{{/if}}{{/each}}

  @override
  List<Object> get props => [
    {{~#each fields}}{{#if name}}
    {{ dartName name }},
    {{/if}}{{/each~}}
  ];

  /// Creates a new [{{ name }}] with non-null values from [other] as attribute overrides
  {{ name }} mergedLeftWith(covariant {{ name }} other) {
    assert(other != null, "$this Cannot be merged with null");
    return {{ name }}(
      {{~#each fields}}{{#if name}}
      {{ dartName name }}: other.{{ dartName name }} ?? {{ dartName name }},
      {{/if}}{{/each~}}
    );
  }
    
  @protected
  Set<String> get missingRequiredFields {
    Set<String> missingFields = Set();
    {{#each fields}}
    {{~#if isRequired}}
    if ({{ dartName name }} == null){
        missingFields.add("{{ dartName name }}");
    }
    {{/if}}
    {{/each}}
    return missingFields;
  }

  static final String schemaTypeName = "{{ takeFirst typeName name }}";
}

{{/unless}}
