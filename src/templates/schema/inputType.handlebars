{{~#*inline "setField" ~}}
    {{ dartName name }} = {{#if (
        callMethod type
            'endsWith'
            'Input'
        ) ~}}
        {{type}}.from{{ inputBaseType type }}(instance.fields.{{ dartName name }})
    {{~else~}}
        instance.fields.{{ dartName name }}
    {{~/if~}}
{{/inline}}
{{~#*inline "getField" ~}}
    {{ dartName name }}: {{ dartName name ~}}
    {{~#if (
        callMethod type
        'endsWith'
        'Input'
        ) ~}}
        .as{{ inputBaseType type }}()
    {{~/if~}},
{{/inline}}

{{~#*inline "inputTypeHelpers" ~}}
    {{ name }}.from{{ objectType }}({{ objectType }} instance):
        {{#each fields~}}
            {{>setField type=(
                callMethod (
                    resolveType
                        type
                        "inline"
                        (takeFirst contextName ../contextName)
                        (takeFirst contextModels ../contextModels)
                        isArray
                        raw
                        ../name
                )
                'toString'
            )}}{{#unless @last}},{{/unless}}
        {{/each~}};

    {{ objectType }} as{{ objectType }}() =>
        {{ objectType }}(
            {{#each fields}}
            {{>getField type=(
                callMethod (
                    resolveType
                        type
                        "inline"
                        (takeFirst contextName ../contextName)
                        (takeFirst contextModels ../contextModels)
                        isArray
                        raw
                        ../name
                )
                'toString'
            )}}
            {{/each}}
        );
{{~/inline~}}

{{#unless (
  ignoreType
    name
      @root.config.replaceTypes
      typeName
      @root.config.irreducibleTypes
)}}

{{!--
    input types are currently very simple in graphql, see
    https://github.com/graphql/graphql-spec/issues/114#issuecomment-550056235
--}}
@JsonSerializable()
@immutable
class {{ name }} {{
    classExtends baseType='Equatable' mixins=(resolveMixins fields)
}} {
  static final String typeName = "{{ takeFirst typeName name }}";

  {{#each fields}}{{#if type}}{{#if name}}
  {{#if description }}{{ multilineComment description }}
  {{/if}}
  @JsonKey(required: {{isRequired}}, disallowNullValue: {{isRequired}})
  final {{ resolveType type
      'withSerializers'
      (takeFirst contextName ../contextName)
      (takeFirst contextModels ../contextModels)
      isArray
      raw
      ../name
  }} {{ dartName name }};
  {{~/if}}{{/if}}{{/each}}

  {{name}}({
    {{#each fields}}{{#if name~}}
      {{#if isRequired }}@required {{/if~}}
      this.{{ dartName name }},
    {{/if}}{{/each~}}
  });

  @protected
  Set<String> get missingRequiredFields {
    Set<String> missingFields = Set();
    {{#each fields}}
    {{~#if isRequired}}
    if ({{ dartName name }}  == null){
        missingFields.add("{{ dartName name }}");
    }
    {{/if}}
    {{/each}}
    return missingFields;
  }

  void validate(){
    final missing = missingRequiredFields;
    assert(missing.isEmpty, "$runtimeType#$hashCode is missing required fields $missing"); 
  }

  bool get isValid => missingRequiredFields.isEmpty;

  @override
  List<Object> get props => [
    {{~#each fields}}{{#if name}}
    {{ camelCase (dartName name) }},
    {{/if}}{{/each~}}
  ];

  /// Creates a new `{{ className }}` with the given non-null values overridden
  const {{name}} copyWith({
    {{#each fields}}{{#if name~}}
      {{ resolveType type
            'inline'
            (takeFirst contextName ../contextName)
            (takeFirst contextModels ../contextModels)
            isArray
            raw
            ../name
      }} {{ camelCase (dartName name) }}
    {{/if}}{{/each~}}
  }): {{name}}({
    {{#each fields}}{{#if name~}}
    {{ camelCase (dartName name) }}: {{ camelCase (dartName name) }} ?? this.{{ camelCase (dartName name) }},
    {{/if}}{{/each~}}
  });

  /// Creates a new `{{ name }}` with non-null values from [other] as attribute overrides
  {{ name }} mergedLeftWith(covariant {{ name }} other) {
    assert(other != null, "$this Cannot be merged with null");
    return {{ name }}(
      {{~#each fields}}{{#if name}}
      {{ camelCase (dartName name) }}: other.{{ camelCase (dartName name) }} ?? {{ camelCase (dartName name) }},
      {{/if}}{{/each~}}
    );
  }

  /// Creates a new `{{ name }}` with non-null values from [other] as attribute defaults
  {{ name }} mergedRightWith(covariant {{ name }} other) {
    assert(other != null, "$this Cannot be merged with null");
    return other.mergedLeftWith(this);
  }

  {{#each (addInputHelpers name) ~}}
  {{> inputTypeHelpers .. objectType=this }}
  {{/each}}

  factory {{name}}.fromJson(Map<String, dynamic> json) => 
      _${{name}}FromJson(json);

  Map<String, dynamic> toJson() => _${{name}}ToJson(this);

}

{{/unless}}
