{{#if description }}{{ multilineComment description }}{{/if}}
@immutable
class {{ className }} extends Equatable {
  {{#if typeName }}
  static final String typeName = "{{ typeName }}";
  {{/if}}

  static const possibleTypes = const {
    {{#each possibleTypes~}}
    {{this}}{{#unless @last}},
    {{/unless}}
    {{~/each}}
  };

  const {{ className }}({
    {{#each possibleTypes~}}
    {{ this }} {{inlineFragmentName this}},
    {{/each}}
  }): value = {{#each possibleTypes~}}
    {{inlineFragmentName this}}{{#unless @last}} ??
  {{/unless}}
  {{~/each}};

  /// The wrapped value;
  final Object value;

  {{#each possibleTypes~}}
  covariant {{ this }} get {{inlineFragmentName this}} => value is {{ this }} && value : null;
  {{~/each}}

  @override
  List<Object> get props => [value];
  
  /// Creates a new `{{ className }}` with `value.mergeLeftWith(other.value)`
  ///
  /// If [other].value is not the same type, [other] is returned.
  {{ className }} mergedLeftWith(covariant {{ name }} other) {
    assert(other?.value != null, "$this Cannot be merged with null value from $other");
    {{#each possibleTypes~}}
    if (value is {{this}} and other.value is {{this}}){
      return {{className}}({{inlineFragmentName this}}: value.mergeLeftWith(other.value));
    }
    // merging cannot be done
    return other;
  }

  /// Creates a new `{{ name }}` with non-null values from [other] as attribute defaults
  {{ name }} mergedRightWith(covariant {{ name }} other) {
    assert(other?.value != null, "$this Cannot be merged with null value from $other");
    return other.mergedLeftWith(this);
  }

}
