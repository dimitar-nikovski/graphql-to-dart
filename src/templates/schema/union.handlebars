@immutable
{{#if description }}{{ multilineComment description }}{{/if}}
class {{ className }} extends Equatable {
  {{#if typeName }}
  static final String schemaTypeName = "{{ typeName }}";
  {{/if}}

  static const possibleTypes = const {
    {{#each possibleTypes~}}
    {{this}}{{#unless @last}},
    {{/unless}}
    {{~/each}}
  };

  {{#each possibleTypes~}}
  final {{ this }} {{inlineFragmentName this}};
  {{/each}}


  const {{ className }}({
    {{#each possibleTypes~}}
    this.{{inlineFragmentName this}},
    {{/each}}
  });

  /// The wrapped value. Will be one of the `possibleTypes`
  Object get value => {{#each possibleTypes~}}
    {{inlineFragmentName this}} {{#unless @last}}??{{/unless}}
    {{~/each}};

  @override
  List<Object> get props => [value];
  
  /// Creates a new `{{ className }}` with `value.mergedLeftWith(other.value)`
  ///
  /// If [other].value is not the same type, [other] is returned.
  {{ className }} mergedLeftWith(covariant {{ name }} other) {
    assert(other?.value != null, "$this Cannot be merged with null value from $other");
    {{#each possibleTypes~}}
    if ({{inlineFragmentName this}} != null && other.{{inlineFragmentName this}} != null){
      return {{../className}}({{inlineFragmentName this}}: {{inlineFragmentName this}}.mergedLeftWith(other.{{inlineFragmentName this}}));
    }
    {{/each}}
    // merging cannot be done
    return other;
  }

  /// Creates a new `{{ name }}` with non-null values from [other] as attribute defaults
  {{ name }} mergedRightWith(covariant {{ name }} other) {
    assert(other?.value != null, "$this Cannot be merged with null value from $other");
    return other.mergedLeftWith(this);
  }

}
