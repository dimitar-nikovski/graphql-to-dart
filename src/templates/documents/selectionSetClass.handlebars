@JsonSerializable()
class {{ className }} {{

    classExtends
        baseType=typeName
        mixins=(resolveMixins allFields)
        fragments=fragmentsSpread
        interfaces=interfaces

}} {
  {{#if typeName }}
  static final String schemaTypeName = "{{ typeName }}";
  {{/if}}

  @JsonKey(name: r'__typename', required: false, disallowNullValue: true)
  /// The `__typename` meta-field 
  ///
  /// GraphQL supports type name introspection at any point within a query by the meta-field `__typename: String!` ([spec])
  ///
  /// [reference]: https://github.com/graphql/graphql-spec/blob/c7bface58bf6f58cc809f279cba1b6245de914b4/spec/Section%204%20--%20Introspection.md#type-name-introspection)
  String {{ camelCase (dartName @root.config.typenameField) }};

  {{> selectionSet }}

  {{#if hasInlineFragments~}}
  {{#each inlineFragments}}
  @JsonKey(ignore: true)
  final {{ concat ../contextName name }} {{ inlineFragmentName name}};
  {{/each}}
  {{~/if}}

  @override
  List<Object> get props => [
    ...super.props,
    {{~#eachUniqueBy allFields uniqueField='schemaFieldName' prefix='super(' noDupeSuffix=');'}}{{else}}
    {{dartName name}},
    {{/eachUniqueBy~}},
    {{#if hasInlineFragments~}}
    {{#each inlineFragments}}
    {{ inlineFragmentName name}},
    {{/each}}
    {{~/if}}
  ];

  const {{className}}({
    this.{{ camelCase (dartName @root.config.typenameField) }},
    {{#each inlineFragments~}}
    this.{{ inlineFragmentName name}},
    {{~/each}}
    {{#emptySafeEach allFields required='name' }}
      {{~#if name != '__typename'}}
      {{#if isRequired }}@required {{/if~}}
      {{ resolveType type
          isRequired
          (takeFirst contextName ../contextName)
          (takeFirst contextModels ../contextModels)
          isArray
          raw
          ../name
      }} {{dartName name}},
      {{/if~}}
    {{/emptySafeEach}} {{!-- VV coupled to the same eachUniqueBy in selectionSet --}}
  }): {{#eachUniqueBy allFields uniqueField='schemaFieldName' prefix='super(' noDupeSuffix=');'}}{{else}}
        this.{{dartName name}} = {{dartName name}},{{/eachUniqueBy}}
    super(
      {{~#eachUniqueBy allFields uniqueField='schemaFieldName'}}
      {{dartName schemaFieldName}}: {{dartName name}},
      {{/eachUniqueBy~}}
    );

  @protected
  Set<String> get missingRequiredFields {
    Set<String> missingFields = Set();
    {{#each allFields}}
    {{~#if isRequired}}
    if ({{ camelCase (dartName name) }} == null){
      missingFields.add("
      {{~ camelCase (dartName name) ~}}
      {{~#if isAliased}} aliased from {{ dartName schemaFieldName }}
      {{~/if~}}
      ");
    }
    {{/if}}
    {{/each}}
    return missingFields;
  }

  /// Creates a new `{{ className }}` with the given non-null values overridden
  {{ className }} copyWith(
    String {{ camelCase (dartName @root.config.typenameField) }},
    {{#each inlineFragments~}}
    {{ concat ../contextName name }} {{ inlineFragmentName name}},
    {{~/each}}
    {{#emptySafeEach allFields required='name' }}
      {{~#if name != '__typename'}}
      {{ resolveType type
          isRequired
          (takeFirst contextName ../contextName)
          (takeFirst contextModels ../contextModels)
          isArray
          raw
          ../name
      }} {{dartName name}},
      {{/if~}}
    {{/emptySafeEach}}
  } => {{ className }}(
    {{ camelCase (dartName @root.config.typenameField) }}: {{ camelCase (dartName @root.config.typenameField) }} ?? this.{{ camelCase (dartName @root.config.typenameField) }},
    {{#each inlineFragments~}}
    {{ inlineFragmentName name}}: {{ inlineFragmentName name}} != null ?
      {{#if isArray~}}
      other.{{ inlineFragmentName name}}
      {{~else~}}
      this.{{ inlineFragmentName name}}?.mergedLeftWith({{ inlineFragmentName name}}) ?? {{ inlineFragmentName name}}
      {{~/if}}
      : this.{{ inlineFragmentName name}},
    {{~/each}}
    {{#emptySafeEach allFields required='name' }}
      {{~#if name != '__typename'}}
      {{ camelCase (dartName name) }}: {{ camelCase (dartName name) }} ?? this.{{ camelCase (dartName name) }},
      {{/if~}}
    {{/emptySafeEach}}
  );

  /// Creates a new `{{ className }}` with non-null values from [other] as attribute overrides
  @override
  {{ className }} mergeLeftWith(covariant {{ className }} other) {
    assert(other != null, "$this Cannot be merged with null");
    return copyWith(
      {{ camelCase (dartName @root.config.typenameField) }}: other.{{ camelCase (dartName @root.config.typenameField) }},
      {{#each inlineFragments~}}
      {{ concat ../contextName name }}:  {{ inlineFragmentName name}},
      {{~/each}}
      {{#emptySafeEach allFields required='name' }}
      {{~#if name != '__typename'}}
      {{ camelCase (dartName name) }}: other.{{ camelCase (dartName name) }},
      {{/if~}}
      {{/emptySafeEach}}
    );
  }

  /// Creates a new `{{ className }}` with non-null values from [other] as attribute defaults
  {{ className }} mergedRightWith(covariant {{ className }} other) {
    assert(other != null, "$this Cannot be merged with null");
    return other.mergedLeftWith(this);
  }

  factory {{className}}.fromJson(Map<String, dynamic> json) =>
     _${{className}}FromJson(json){{#if hasInlineFragments~}}
      .copyWith(
        {{~#each inlineFragments}}
        {{ inlineFragmentName name}}: {{ concat ../contextName name }}.schemaTypeName == json['__typename']
          ? {{ concat ../contextName name }}.fromJson(json)
          : null,
        {{/each}}
      )
      {{~/if}};

  Map<String, dynamic> toJson() {
    Map<String, dynamic> json = _${{className}}ToJson(this);

    {{#if hasInlineFragments~}}
    {{#each inlineFragments}}
    if ({{ inlineFragmentName name}} != null){
        json.addAll({{ inlineFragmentName name}}.toJson());
    }
    {{/each}}
    {{~/if}}

    return json;
  }


}
